#!/usr/bin/env python3

import argparse
import os
import re
import sys
from typing import Dict, Optional, List, Set, Tuple
from pathlib import Path
from subprocess import CalledProcessError, PIPE, Popen

from gitrevise.utils import EditorError
from gitrevise.odb import Repository
from gitrevise.merge import rebase, MergeConflict

USAGE = """\
Create branches for commits in @{upstream}..  if their commit message
subject starts with [<topic>] where <topic> is the desired branch name.
"""

SUBJECT_PREFIX_PREFIX = b"["
SUBJECT_PREFIX_SUFFIX = b"]"

CommitEntries = List[Tuple[str, str, str]]

def parse_log(repo, base_commit) -> Tuple[CommitEntries, Dict[str, Set[str]]]:
    commit_entries = []
    dependency_graph: Dict[str, Set[str]] = {}
    patches = (
        repo.git("log", f"{base_commit}..HEAD", "--reverse", "--format=%H %s")
        .decode()
        .splitlines()
    )
    prefix_prefix = repo.config(
        f"branchless.subjectPrefixPrefix",
        default=SUBJECT_PREFIX_PREFIX,
    ).decode()
    prefix_suffix = repo.config(
        f"branchless.subjectPrefixSuffix",
        default=SUBJECT_PREFIX_SUFFIX,
    ).decode()
    for line in patches:
        words = line.split(maxsplit=2)
        if len(words) < 3:
            continue
        commit, prefix, subject = words
        if not prefix.startswith(prefix_prefix) or not prefix.endswith(prefix_suffix):
            continue

        prefix = prefix[len(prefix_prefix) : -len(prefix_suffix)]
        topic_with_parents = prefix.split(":")
        topic = topic_with_parents[0]
        parent_topics = [t for t in topic_with_parents[1:] if t]

        # An empty topic means to reuse the previous topic.
        if not topic:
            continue

        commit_entries += [(commit, topic, subject)]

        if topic not in dependency_graph:
            dependency_graph[topic] = set()
        if parent_topics:
            dependency_graph[topic].update(parent_topics)

    return commit_entries, dependency_graph

def transitive_dependencies(depgraph: Dict[str, Set[str]], node: str) -> Set[str]:
    visited: Set[str] = set()
    transitive_dependencies_rec(depgraph, node, visited)
    return visited

def transitive_dependencies_rec(
    depgraph: Dict[str, Set[str]], node: str, visited: Set[str]
) -> None:
    if node in visited:
        return
    visited.add(node)
    for x in depgraph.get(node, ()):
        transitive_dependencies_rec(depgraph, x, visited)

class BranchWasModifiedError(Exception):
    pass

class TopicNotFoundError(Exception):
    pass

def validate_cache(repo, topic_set, force):
    cache_path = repo.gitdir / "branchless-cache"
    if not os.path.exists(cache_path):
        return
    cached_shas = [
        (w[0], w[1])
        for w in map(
            lambda line: line.split(), cache_path.read_bytes().decode().splitlines()
        )
    ]
    existing_branches = {}
    refs = repo.git(
        "for-each-ref",
        "--format",
        "%(refname:short) %(objectname)",
        *[f"refs/heads/{t[0]}" for t in cached_shas],
    )
    for line in refs.decode().splitlines():
        refname, sha = line.split(" ", maxsplit=1)
        existing_branches[refname] = sha
    for topic, cached_sha in cached_shas:
        if topic not in existing_branches:
            continue
        if topic not in topic_set:  # The user did not ask to create this branch.
            continue
        current_sha = existing_branches[topic]
        if current_sha == cached_sha:
            continue
        if force:
            print(f"Will overwrite modified branch {topic}")
        else:
            raise BranchWasModifiedError(topic)

def update_cache(repo, topics):
    cache_path = repo.gitdir / "branchless-cache"
    mode = "r+" if cache_path.exists() else "w+"
    with open(cache_path, mode) as f:
        cached_shas = {
            w[0]: w[1] for w in map(lambda line: line.split(), f.read().splitlines())
        }
        new_topics = cached_shas
        for t in topics:
            if topics[t] is not None:
                new_topics[t] = topics[t]
        new_content = ""
        for topic in new_topics:
            sha = new_topics[topic]
            if sha is not None:
                new_content += f"{topic} {sha}{os.linesep}"
        f.seek(0)
        f.truncate()
        f.write(new_content)

def create_branches(
    repo, current_branch, base_commit, branches=None, force=False
) -> None:
    commit_entries, dependency_graph = parse_log(repo, base_commit)
    def by_first_commit_on_topic(commit_entry):
        (commit, topic, subject) = commit_entry
        for i in range(len(commit_entries)):
            if commit_entries[i][1] == topic:
                return i
        return -1
    commit_entries.sort(key=by_first_commit_on_topic)
    topics = {commit_entry[1]: None for commit_entry in commit_entries}
    all_topics = set(topics)
    topic_set = all_topics

    if branches:
        for topic in branches:
            if topic not in all_topics:
                raise TopicNotFoundError(topic, base_commit)
        topic_set = set()
        for topic in branches:
            topic_set.add(topic)
        topics = {t: None for t in topics if t in topic_set}

    for child in topics:
        for parent in dependency_graph[child]:
            if parent not in all_topics:
                print(f"Warning: topic '{child}' depends on missing topic '{parent}'.")

    assert current_branch not in set(
        topics
    ), f"Refusing to overwrite current branch {current_branch}"

    validate_cache(repo, topic_set, force)

    base_commit_id = repo.git("rev-parse", base_commit).decode()
    for topic in topics:
        head = repo.get_commit(base_commit_id)
        deps = transitive_dependencies(dependency_graph, topic)
        new_messages = []
        for commit, t, commit_subject in commit_entries:
            if t not in deps or t == topic:
                continue
            patch = repo.get_commit(commit)
            match = None
            new_messages += [patch.message]
            head = rebase(patch, head)
        for commit, t, subject in commit_entries:
            if t != topic:
                continue
            patch = repo.get_commit(commit)
            body = b"\n".join(patch.message.split(b"\n", maxsplit=1)[1:])
            message = subject.encode() + b"\n" + body

            head = rebase(patch, head)
            head = head.update(message=message)

            new_messages += [head.message]
        topic_fqn = f"refs/heads/{topic}"
        if not repo.git("branch", "--list", topic):
            repo.git("branch", topic, base_commit)
        topic_ref = repo.get_commit_ref(topic_fqn)

        old_commits = (
            repo.git(
                "log",
                f"{base_commit}..{topic_fqn}",
                "--reverse",
                "--format=%H",
            )
            .decode()
            .splitlines()
        )
        old_messages = [repo.get_commit(commit).message for commit in old_commits]

        if head.tree() != topic_ref.target.tree() or new_messages != old_messages:
            topic_oid = topic_ref.target.oid
            print(f"Updating {topic_ref.name} ({topic_oid} => {head.oid})")
            topic_ref.update(head, "git-branchless rewrite")

        topics[topic] = topic_ref.target.oid

    update_cache(repo, topics)

    for topic in topics:
        print(topic)
        for line in (
            repo.git("log",f"{base_commit}..refs/heads/{topic}",  "--oneline")
            .decode()
            .splitlines()
        ):
            print("\t", line)

def dwim(repo: Repository) -> Tuple[str, str]:
    root = Path(repo.git("rev-parse", "--show-toplevel").decode().strip())
    rebase_dir = root / ".git/rebase-merge"

    if os.path.exists(rebase_dir):
        with open(rebase_dir / "head-name") as f:
            branch = os.path.basename(f.read().strip())
        with open(rebase_dir / "onto") as f:
            base_commit = f.read().strip()
    else:
        branch = repo.git("symbolic-ref", "--short", "HEAD").decode()
        base_commit = "@{upstream}"

    return branch, base_commit

def parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="git branchless",
        description=USAGE,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    p.add_argument(
        "<topic>",
        nargs="*",
        help="only create the given branches",
    )

    p.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="overwrite branches even if they were modified since the last run",
    )

    return p

def main(argv: Optional[List[str]] = None):
    args = parser().parse_args(argv)
    try:
        with Repository() as repo:
            branch, base_commit = dwim(repo)
            create_branches(
                repo, branch, base_commit, getattr(args, "<topic>"), force=args.force
            )
    except BranchWasModifiedError as err:
        print(
            f"error: generated branch {err} has been modified. Use --force to overwrite."
        )
        sys.exit(1)
    except CalledProcessError as err:
        print(f"subprocess exited with non-zero status: {err.returncode}")
        sys.exit(1)
    except EditorError as err:
        print(f"editor error: {err}")
        sys.exit(1)
    except MergeConflict as err:
        print(f"merge conflict: {err}")
        sys.exit(1)
    except TopicNotFoundError as err:
        topic, base_commit = err.args
        print(f"error: topic '{topic}' not found {base_commit}..")
    except ValueError as err:
        print(f"invalid value: {err}")
        sys.exit(1)

if __name__ == "__main__":
    main()
