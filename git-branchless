#!/usr/bin/env python3

from typing import Optional, List
import argparse
from subprocess import CalledProcessError, PIPE, run
import subprocess
import re
import sys

from gitrevise.utils import EditorError
from gitrevise.odb import Repository
from gitrevise.merge import rebase, MergeConflict

NAME = 'git-branchless'

USAGE = """\
Create some commits with commit messages starting with `[topic] ` where `topic`
is any valid branch name.  Then run `git branchless` to create a branch
for each of those topics among commits in the range `@{upstream}..HEAD`.
Each topic branch is the result of applying the topic's commits on top of
`@{upstream}`.

For example, if you have a history like

    $ git log @{u}.. --format=%s
    WIP Some unfinished work
    [my-awesome-feature] Some more work on feature
    [some-independent-fix] Unrelated fix
    [my-awesome-feature] Initial support for feature

Then this command will create two branches:

    $ git branchless
    Updating refs/heads/my-awesome-feature (ba5e58a => 48a53fec)
    Updating refs/heads/some-independent-fix (ba5e58a => e612f26e)

    my-awesome-feature
        9d33b57e Initial support for feature
        48a53fec Some more work on feature

    some-independent-fix
        e612f26e Unrelated fix

When you add another commit, or update a previous one, simply re-run `git
branchless` to update the generated topic branches.

Commits whose message does not start with a topic tag, are ignored.
Use the special commit message prefix `[]` to reuse the prevous commit's topic.

If there is a merge conflict, you will be prompted to resolve it.  However,
it is usually a good idea to avoid this by using the same topic for dependent
commits.
"""

UPSTREAM = "@{upstream}"


def update_branches_from_HEAD(repo, args):
    log = []
    patches = (repo.git("log", "--reverse", "--oneline",
                        f"{UPSTREAM}..HEAD").decode().splitlines())
    current_topic = None
    for line in patches:
        match = re.match(r"^(\S*)(?: \[([^\]]*)\])?", line)
        if match is None:
            break

        commit = match.group(1)
        topic = match.group(2)

        if topic is None:
            continue

        # [] reuses the previous topic
        if topic != '':
            current_topic = topic

        if current_topic:
            log += [(commit, current_topic)]

    topics = sorted(list({l[1] for l in log}))

    if args.topics:
        print('\n'.join(topics))
        sys.exit(0)

    current_branch = repo.git("symbolic-ref", "--short", "HEAD").decode()
    assert current_branch not in topics
    upstream_id = repo.git("rev-parse", UPSTREAM).decode()
    for topic in topics:
        head = repo.get_commit(upstream_id)
        new_messages = []
        for commit, t in log:
            if t != topic:
                continue
            patch = repo.get_commit(commit)
            head = rebase(patch, head)
            for prefix in ('[] '), f"[{topic}] ":
                prefix = bytes(prefix, 'utf8')
                if head.message.startswith(prefix):
                    head = head.update(message=patch.message[len(prefix):])
                    break
            new_messages += [head.message]
        if not repo.git('rev-parse', '--revs-only', topic):
            repo.git("branch", topic, UPSTREAM)
        topic_ref = repo.get_commit_ref(topic)

        old_commits = repo.git("log", "--reverse", "--oneline", "--format=%H",
                               f"{UPSTREAM}..{topic}").decode().splitlines()
        old_messages = [
            repo.get_commit(commit).message for commit in old_commits
        ]

        if (head.tree() == topic_ref.target.tree()
                and new_messages == old_messages):
            continue

        topic_oid = topic_ref.target.oid
        print(f"Updating {topic_ref.name} ({topic_oid} => {head.oid})")
        topic_ref.update(head, "git-branchless rewrite")

    for topic in topics:
        print()
        print(topic)
        for line in repo.git('log', '--oneline',
                             f'{UPSTREAM}..{topic}').decode().splitlines():
            print('\t', line)


def parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog=NAME,
        description=USAGE,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    p.add_argument(
        "--topics",
        "-t",
        action="store_true",
        help="print topic branch names and exit",
    )

    return p


def main(argv: Optional[List[str]] = None):
    args = parser().parse_args(argv)
    try:
        with Repository() as repo:
            update_branches_from_HEAD(repo, args)
    except CalledProcessError as err:
        print(f"subprocess exited with non-zero status: {err.returncode}")
        sys.exit(1)
    except EditorError as err:
        print(f"editor error: {err}")
        sys.exit(1)
    except MergeConflict as err:
        print(f"merge conflict: {err}")
        sys.exit(1)
    except ValueError as err:
        print(f"invalid value: {err}")
        sys.exit(1)


if __name__ == "__main__":
    main()
