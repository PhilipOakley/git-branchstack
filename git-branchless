#!/usr/bin/env python3

import argparse
import os
import re
import sys
from typing import Dict, Optional, List, Set, Tuple
from pathlib import Path
from subprocess import CalledProcessError, PIPE

from gitrevise.utils import EditorError
from gitrevise.odb import Repository
from gitrevise.merge import rebase, MergeConflict

NAME = "git-branchless"

USAGE = """\
Create some commits with commit messages starting with `[topic] ` where `topic`
is any valid branch name.  Then run `git branchless` to create a branch
for each of those topics among commits in the range `@{upstream}..HEAD`.
Each topic branch is the result of applying the topic's commits on top of
`@{upstream}`.

For example, if you have a history like

    $ git log @{upstream}.. --format=%s
    WIP unfinished commit
    [some-unrelated-fix] Unrelated fix
    [my-awesome-feature] Some more work on feature
    [my-awesome-feature] Initial support for feature

Then this command will create two branches:

    $ git branchless
    Updating refs/heads/my-awesome-feature (ba5e58a => 48a53fec)
    Updating refs/heads/some-unrelated-fix (ba5e58a => e612f26e)

    my-awesome-feature
        9d33b57e Initial support for feature
        48a53fec Some more work on feature

    some-unrelated-fix
        e612f26e Unrelated fix

When you add another commit, or update a previous one, simply re-run `git
branchless` to update the generated topic branches.

Commits whose message does not start with a topic tag are ignored.

If there is a merge conflict, you will be prompted to resolve it.
To avoid conflicts, you can specify dependencies between branches.
For example use `[child:parent1:parent2]` to base `child` off both `parent1`
and `parent2`.

Instead of the default `[` and `]` guards, you can set
`branchless.subjectPrefixPrefix` and `branchless.subjectPrefixSuffix`,
respectively.
"""

SUBJECT_PREFIX_PREFIX = b"["
SUBJECT_PREFIX_SUFFIX = b"]"

CommitEntries = List[Tuple[str, str, str]]


def parse_log(repo, base_commit) -> Tuple[CommitEntries, Dict[str, Set[str]]]:
    commit_entries = []
    dependency_graph: Dict[str, Set[str]] = {}
    patches = (
        repo.git("log", "--reverse", "--oneline", f"{base_commit}..HEAD")
        .decode()
        .splitlines()
    )
    prefix_prefix = repo.config(
        f"branchless.subjectPrefixPrefix",
        default=SUBJECT_PREFIX_PREFIX,
    ).decode()
    prefix_suffix = repo.config(
        f"branchless.subjectPrefixSuffix",
        default=SUBJECT_PREFIX_SUFFIX,
    ).decode()
    for line in patches:
        words = line.split(maxsplit=2)
        if len(words) < 3:
            continue
        commit, prefix, subject = words
        if not prefix.startswith(prefix_prefix) or not prefix.endswith(prefix_suffix):
            continue

        prefix = prefix[len(prefix_prefix) : -len(prefix_suffix)]
        topic_with_parents = prefix.split(":")
        topic = topic_with_parents[0]
        parent_topics = [t for t in topic_with_parents[1:] if t]

        # An empty topic means to reuse the previous topic.
        if not topic:
            continue

        commit_entries += [(commit, topic, subject)]

        if topic not in dependency_graph:
            dependency_graph[topic] = set()
        if parent_topics:
            dependency_graph[topic].update(parent_topics)

    return commit_entries, dependency_graph


def transitive_dependencies(depgraph: Dict[str, Set[str]], node: str) -> Set[str]:
    visited: Set[str] = set()
    transitive_dependencies_rec(depgraph, node, visited)
    return visited


def transitive_dependencies_rec(
    depgraph: Dict[str, Set[str]], node: str, visited: Set[str]
) -> None:
    if node in visited:
        return
    visited.add(node)
    for x in depgraph.get(node, ()):
        transitive_dependencies_rec(depgraph, x, visited)


class BranchWasModifiedError(Exception):
    pass


def validate_cache(repo, topic_set, force):
    cache_path = repo.gitdir / "branchless-cache"
    if os.path.exists(cache_path):
        with open(cache_path, "r") as f:
            cached_shas = [
                (w[0], w[1])
                for w in map(lambda line: line.split(), f.read().splitlines())
            ]
        current_shas = (
            repo.git("rev-parse", *[f"refs/heads/{t[0]}" for t in cached_shas])
            .decode()
            .splitlines()
        )
        for i, current_sha in enumerate(current_shas):
            topic, cached_sha = cached_shas[i]
            if topic not in topic_set:
                continue
            if current_sha == cached_sha:
                continue
            if force:
                print(f"Will overwrite modified branch {topic}")
            else:
                raise BranchWasModifiedError(topic)


def update_cache(repo, topics):
    cache_path = repo.gitdir / "branchless-cache"
    with open(cache_path, "w+") as f:
        cached_shas = {
            w[0]: w[1] for w in map(lambda line: line.split(), f.read().splitlines())
        }
        new_topics = cached_shas
        for t in topics:
            if topics[t] is not None:
                new_topics[t] = topics[t]
        new_content = ""
        for topic in new_topics:
            sha = new_topics[topic]
            if sha is not None:
                new_content += f"{topic} {sha}{os.linesep}"
        f.seek(0)
        f.truncate()
        f.write(new_content)


def create_branches(
    repo, current_branch, base_commit, topics_to_create=None, force=False
) -> None:
    commit_entries, dependency_graph = parse_log(repo, base_commit)

    def by_first_commit_on_topic(commit_entry):
        (commit, topic, subject) = commit_entry
        for i in range(len(commit_entries)):
            if commit_entries[i][1] == topic:
                return i
        return -1

    commit_entries.sort(key=by_first_commit_on_topic)
    topics = {commit_entry[1]: None for commit_entry in commit_entries}
    all_topics = set(topics)
    topic_set = all_topics

    if topics_to_create:
        topic_set = set()
        for topic in topics_to_create:
            topic_set.add(topic)
        topics = {t: None for t in topics if t in topic_set}

    for child in topics:
        for parent in dependency_graph[child]:
            if parent not in all_topics:
                print(f"Warning: topic '{child}' depends on missing topic '{parent}'.")

    assert current_branch not in set(
        topics
    ), f"Refusing to overwrite current branch {current_branch}"

    validate_cache(repo, topic_set, force)

    base_commit_id = repo.git("rev-parse", base_commit).decode()
    for topic in topics:
        head = repo.get_commit(base_commit_id)
        deps = transitive_dependencies(dependency_graph, topic)
        new_messages = []
        for commit, t, commit_subject in commit_entries:
            if t not in deps or t == topic:
                continue
            patch = repo.get_commit(commit)
            match = None
            new_messages += [patch.message]
            head = rebase(patch, head)
        for commit, t, subject in commit_entries:
            if t != topic:
                continue
            patch = repo.get_commit(commit)
            body = b"\n".join(patch.message.split(b"\n", maxsplit=1)[1:])
            message = subject.encode() + b"\n" + body

            head = rebase(patch, head)
            head = head.update(message=message)

            new_messages += [head.message]
        if (
            not repo.git("rev-parse", "--revs-only", topic)
            or repo.git("cat-file", "-t", topic).decode() != "commit"
        ):
            repo.git("branch", topic, base_commit)
        topic_ref = repo.get_commit_ref(topic)

        old_commits = (
            repo.git(
                "log",
                "--reverse",
                "--oneline",
                "--format=%H",
                f"{base_commit}..{topic}",
            )
            .decode()
            .splitlines()
        )
        old_messages = [repo.get_commit(commit).message for commit in old_commits]

        if head.tree() != topic_ref.target.tree() or new_messages != old_messages:
            topic_oid = topic_ref.target.oid
            print(f"Updating {topic_ref.name} ({topic_oid} => {head.oid})")
            topic_ref.update(head, f"{NAME} rewrite")

        topics[topic] = topic_ref.target.oid

    update_cache(repo, topics)

    for topic in topics:
        print(topic)
        for line in (
            repo.git("log", "--oneline", f"{base_commit}..{topic}")
            .decode()
            .splitlines()
        ):
            print("\t", line)


def dwim(repo: Repository) -> Tuple[str, str]:
    root = Path(repo.git("rev-parse", "--show-toplevel").decode().strip())
    rebase_dir = root / ".git/rebase-merge"

    if os.path.exists(rebase_dir):
        with open(rebase_dir / "head-name") as f:
            branch = os.path.basename(f.read().strip())
        with open(rebase_dir / "onto") as f:
            base_commit = f.read().strip()
    else:
        branch = repo.git("symbolic-ref", "--short", "HEAD").decode()
        base_commit = "@{upstream}"

    return branch, base_commit


def parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog=NAME,
        description=USAGE,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    p.add_argument(
        "<topic>",
        nargs="*",
        help="only create the given branches",
    )

    p.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="overwrite branches even if they were modified since the last run",
    )

    return p


def main(argv: Optional[List[str]] = None):
    args = parser().parse_args(argv)
    try:
        with Repository() as repo:
            branch, base_commit = dwim(repo)
            create_branches(
                repo, branch, base_commit, getattr(args, "<topic>"), force=args.force
            )
    except BranchWasModifiedError as err:
        print(
            f"error: generated branch {err} has been modified. Use --force to overwrite."
        )
        sys.exit(1)
    except CalledProcessError as err:
        print(f"subprocess exited with non-zero status: {err.returncode}")
        sys.exit(1)
    except EditorError as err:
        print(f"editor error: {err}")
        sys.exit(1)
    except MergeConflict as err:
        print(f"merge conflict: {err}")
        sys.exit(1)
    except ValueError as err:
        print(f"invalid value: {err}")
        sys.exit(1)


if __name__ == "__main__":
    main()
