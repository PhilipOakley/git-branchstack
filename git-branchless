#!/usr/bin/env python3

import argparse
import os
import re
import sys
from typing import Dict, Optional, List, Set, Tuple
from pathlib import Path
from subprocess import CalledProcessError, PIPE

from gitrevise.utils import EditorError
from gitrevise.odb import Repository
from gitrevise.merge import rebase, MergeConflict

NAME = "git-branchless"

USAGE = """\
Create some commits with commit messages starting with `[topic] ` where `topic`
is any valid branch name.  Then run `git branchless` to create a branch
for each of those topics among commits in the range `@{upstream}..HEAD`.
Each topic branch is the result of applying the topic's commits on top of
`@{upstream}`.

For example, if you have a history like

    $ git log @{upstream}.. --format=%s
    WIP unfinished commit
    [some-unrelated-fix] Unrelated fix
    [my-awesome-feature] Some more work on feature
    [my-awesome-feature] Initial support for feature

Then this command will create two branches:

    $ git branchless
    Updating refs/heads/my-awesome-feature (ba5e58a => 48a53fec)
    Updating refs/heads/some-unrelated-fix (ba5e58a => e612f26e)

    my-awesome-feature
        9d33b57e Initial support for feature
        48a53fec Some more work on feature

    some-unrelated-fix
        e612f26e Unrelated fix

When you add another commit, or update a previous one, simply re-run `git
branchless` to update the generated topic branches.

Commits whose message does not start with a topic tag are ignored.

If there is a merge conflict, you will be prompted to resolve it.  However,
it is usually a good idea to avoid this by using the same topic for dependent
commits.

You can specify dependencies between branches for example use
`[child:parent1:parent2]` to base `child` off both `parent1` and `parent2`.
Please ensure that dependencies appear before users in your branch.
"""

SUBJECT_REGEX = rb"\[([^\]:]*)(?::([^\]]*))*\]\s*(.*)"

CommitEntries = List[Tuple[str, str, str]]


def parse_log(repo, base_commit) -> Tuple[CommitEntries, Dict[str, Set[str]]]:
    commit_entries = []
    dependency_graph: Dict[str, Set[str]] = {}
    patches = (
        repo.git("log", "--reverse", "--oneline", f"{base_commit}..HEAD")
        .decode()
        .splitlines()
    )
    subject_regex = repo.config(
        f"branchless.subjectRegex", default=SUBJECT_REGEX
    ).decode()
    for line in patches:
        match = re.match(r"^(\S*) " + subject_regex, line)
        if match is None:
            continue

        commit, topic, parents, subject = match.groups()
        parent_topics = []
        if parents:
            parent_topics = parents.split(":")

        # An empty topic means to reuse the previous topic.
        if not topic:
            continue

        commit_entries += [(commit, topic, subject)]

        if topic not in dependency_graph:
            dependency_graph[topic] = set()
        if parent_topics:
            dependency_graph[topic].update(parent_topics)

    return commit_entries, dependency_graph


def transitive_dependencies(depgraph: Dict[str, Set[str]], node: str) -> Set[str]:
    visited: Set[str] = set()
    transitive_dependencies_rec(depgraph, node, visited)
    return visited


def transitive_dependencies_rec(
    depgraph: Dict[str, Set[str]], node: str, visited: Set[str]
) -> None:
    if node in visited:
        return
    visited.add(node)
    for x in depgraph.get(node, ()):
        transitive_dependencies_rec(depgraph, x, visited)


def create_branches(repo, current_branch, base_commit, topics_to_create=None) -> None:
    commit_entries, dependency_graph = parse_log(repo, base_commit)

    def by_first_commit_on_topic(commit_entry):
        (commit, topic, subject) = commit_entry
        for i in range(len(commit_entries)):
            if commit_entries[i][1] == topic:
                return i
        return -1

    commit_entries.sort(key=by_first_commit_on_topic)
    topics = {commit_entry[1]: None for commit_entry in commit_entries}
    all_topics = set(topics)
    topic_set = all_topics

    if topics_to_create:
        topic_set = set()
        for topic in topics_to_create:
            topic_set.add(topic)
        topics = [t for t in topics if t in topic_set]

    for child in topics:
        for parent in dependency_graph[child]:
            if parent not in all_topics:
                print(f"Warning: topic '{child}' depends on missing topic '{parent}'.")

    assert current_branch not in set(
        topics
    ), f"Refusing to overwrite current branch {current_branch}"

    base_commit_id = repo.git("rev-parse", base_commit).decode()
    for topic in topics:
        head = repo.get_commit(base_commit_id)
        deps = transitive_dependencies(dependency_graph, topic)
        new_messages = []
        for commit, t, commit_subject in commit_entries:
            if t not in deps or t == topic:
                continue
            patch = repo.get_commit(commit)
            match = None
            new_messages += [patch.message]
            head = rebase(patch, head)
        for commit, t, subject in commit_entries:
            if t != topic:
                continue
            patch = repo.get_commit(commit)
            body = b"\n".join(patch.message.split(b"\n", maxsplit=1)[1:])
            message = subject.encode() + b"\n" + body

            head = rebase(patch, head)
            head = head.update(message=message)

            new_messages += [head.message]
        if (
            not repo.git("rev-parse", "--revs-only", topic)
            or repo.git("cat-file", "-t", topic).decode() != "commit"
        ):
            repo.git("branch", topic, base_commit)
        topic_ref = repo.get_commit_ref(topic)

        old_commits = (
            repo.git(
                "log",
                "--reverse",
                "--oneline",
                "--format=%H",
                f"{base_commit}..{topic}",
            )
            .decode()
            .splitlines()
        )
        old_messages = [repo.get_commit(commit).message for commit in old_commits]

        if head.tree() == topic_ref.target.tree() and new_messages == old_messages:
            continue

        topic_oid = topic_ref.target.oid
        print(f"Updating {topic_ref.name} ({topic_oid} => {head.oid})")
        topic_ref.update(head, f"{NAME} rewrite")

    for topic in topics:
        print(topic)
        for line in (
            repo.git("log", "--oneline", f"{base_commit}..{topic}")
            .decode()
            .splitlines()
        ):
            print("\t", line)


def dwim(repo: Repository) -> Tuple[str, str]:
    root = Path(repo.git("rev-parse", "--show-toplevel").decode().strip())
    rebase_dir = root / ".git/rebase-merge"

    if os.path.exists(rebase_dir):
        with open(rebase_dir / "head-name") as f:
            branch = os.path.basename(f.read().strip())
        with open(rebase_dir / "onto") as f:
            base_commit = f.read().strip()
    else:
        branch = repo.git("symbolic-ref", "--short", "HEAD").decode()
        base_commit = "@{upstream}"

    return branch, base_commit


def parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog=NAME,
        description=USAGE,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    p.add_argument(
        "<topic>",
        nargs="*",
        help="only create the given branches",
    )

    return p


def main(argv: Optional[List[str]] = None):
    args = parser().parse_args(argv)
    try:
        with Repository() as repo:
            branch, base_commit = dwim(repo)
            create_branches(repo, branch, base_commit, getattr(args, "<topic>"))
    except CalledProcessError as err:
        print(f"subprocess exited with non-zero status: {err.returncode}")
        sys.exit(1)
    except EditorError as err:
        print(f"editor error: {err}")
        sys.exit(1)
    except MergeConflict as err:
        print(f"merge conflict: {err}")
        sys.exit(1)
    except ValueError as err:
        print(f"invalid value: {err}")
        sys.exit(1)


if __name__ == "__main__":
    main()
