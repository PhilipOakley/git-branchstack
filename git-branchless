#!/usr/bin/env python3

import argparse
import os
import re
import sys
from typing import Dict, Optional, List, Set, Tuple
from pathlib import Path
from subprocess import CalledProcessError, PIPE

from gitrevise.utils import EditorError
from gitrevise.odb import Repository
from gitrevise.merge import rebase, MergeConflict

NAME = "git-branchless"

USAGE = """\
Create some commits with commit messages starting with `[topic] ` where `topic`
is any valid branch name.  Then run `git branchless` to create a branch
for each of those topics among commits in the range `@{upstream}..HEAD`.
Each topic branch is the result of applying the topic's commits on top of
`@{upstream}`.

For example, if you have a history like

    $ git log @{upstream}.. --format=%s
    WIP unfinished commit
    [my-awesome-feature] Some more work on feature
    [some-unrelated-fix] Unrelated fix
    [my-awesome-feature] Initial support for feature

Then this command will create two branches:

    $ git branchless
    Updating refs/heads/my-awesome-feature (ba5e58a => 48a53fec)
    Updating refs/heads/some-unrelated-fix (ba5e58a => e612f26e)

    my-awesome-feature
        9d33b57e Initial support for feature
        48a53fec Some more work on feature

    some-unrelated-fix
        e612f26e Unrelated fix

When you add another commit, or update a previous one, simply re-run `git
branchless` to update the generated topic branches.

Commits whose message does not start with a topic tag are ignored.
Use the special commit message prefix `[]` to reuse the prevous commit's topic.

If there is a merge conflict, you will be prompted to resolve it.  However,
it is usually a good idea to avoid this by using the same topic for dependent
commits.

You can specify dependencies between branches for example use
`[child:parent1:parent2]` to base `child` off both `parent1` and `parent2`.
Please ensure that dependencies appear before users in your branch.
"""

SUBJECT_REGEX = rb"\[([^\]:]*)(?::([^\]]*))*\]\s*(.*)"


def parse_log(repo, forkpoint) -> List[Tuple[str, str, str]]:
    parsed_log = []
    patches = (
        repo.git("log", "--reverse", "--oneline", f"{forkpoint}..HEAD")
        .decode()
        .splitlines()
    )
    current_topic = None
    subject_regex = repo.config(
        f"branchless.subjectRegex", default=SUBJECT_REGEX
    ).decode()
    for line in patches:
        match = re.match(r"^(\S*) " + subject_regex, line)
        if match is None:
            continue

        commit, topic, parents, subject = match.groups()
        parent_topics = []
        if parents:
            parent_topics = parents.split(":")

        # An empty topic means to reuse the previous topic.
        if topic != "":
            current_topic = topic

        if current_topic:
            parsed_log += [(commit, current_topic, parent_topics, subject)]

    return parsed_log


def transitive_dependencies(
    depgraph: Dict[str, List[str]], node: str, visited: Set[str]
) -> List[str]:
    if node in visited:
        return []
    visited.add(node)
    return [node] + [
        n
        for x in depgraph.get(node, ())
        for n in transitive_dependencies(depgraph, x, visited)
    ]


def branch_out_commits_since_forkpoint(repo, current_branch, forkpoint, args) -> None:
    parsed_log = parse_log(repo, forkpoint)

    def topic_index(topic):
        for i in range(len(parsed_log)):
            if parsed_log[i][1] == topic:
                return i
        print(f"Warning: ignoring missing branch '{topic}'.")
        return -1

    # Sort topics by their first commit.
    topics = sorted(list({l[1] for l in parsed_log}), key=topic_index)

    # Dependencies for each topic.
    parent_topics: Dict[str, List[str]] = {
        topic: sorted(
            (
                parent
                for entry in parsed_log
                for parent in entry[2]
                if topic_index(parent) != -1
                if entry[1] == topic
            ),
            key=topic_index,
        )
        for topic in topics
    }

    tmp = set()
    for commit, topic, _, _ in parsed_log:
        for parent in parent_topics.get(topic, ()):
            assert parent in tmp
        tmp.add(topic)

    assert (
        current_branch not in topics
    ), f"Refusing to overwrite current branch {current_branch}"

    if args.topics:
        if topics:
            print("\n".join(topics))
        sys.exit(0)

    forkpoint_id = repo.git("rev-parse", forkpoint).decode()
    for topic in topics:
        head = repo.get_commit(forkpoint_id)
        new_messages = []
        deps = transitive_dependencies(parent_topics, topic, set())[1:]
        for parent_topic in deps:
            for commit, t, _, _ in parsed_log:
                if t != parent_topic:
                    continue
                patch = repo.get_commit(commit)
                head = rebase(patch, head)
        for commit, t, _parent_topics, subject in parsed_log:
            if t != topic:
                continue
            patch = repo.get_commit(commit)
            body = b"\n".join(patch.message.split(b"\n", maxsplit=1)[1:])
            message = subject.encode() + b"\n" + body

            head = rebase(patch, head)
            head = head.update(message=message)

            new_messages += [head.message]
        if not repo.git("rev-parse", "--revs-only", topic) or repo.git("cat-file", "-t", topic).decode() != "commit":
            repo.git("branch", topic, forkpoint)
        topic_ref = repo.get_commit_ref(topic)

        old_commits = (
            repo.git(
                "log", "--reverse", "--oneline", "--format=%H", f"{forkpoint}..{topic}"
            )
            .decode()
            .splitlines()
        )
        old_messages = [repo.get_commit(commit).message for commit in old_commits]

        if head.tree() == topic_ref.target.tree() and new_messages == old_messages:
            continue

        topic_oid = topic_ref.target.oid
        print(f"Updating {topic_ref.name} ({topic_oid} => {head.oid})")
        topic_ref.update(head, f"{NAME} rewrite")

    for topic in topics:
        print()
        print(topic)
        for line in (
            repo.git("log", "--oneline", f"{forkpoint}..{topic}").decode().splitlines()
        ):
            print("\t", line)


def parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog=NAME,
        description=USAGE,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    p.add_argument(
        "--topics",
        "-t",
        action="store_true",
        help="print topic branch names and exit",
    )

    return p


def branch_and_forkpoint(repo: Repository) -> Tuple[str, str]:
    root = Path(repo.git("rev-parse", "--show-toplevel").decode().strip())
    head_name = root / ".git/rebase-merge/head-name"

    if os.path.exists(head_name):
        with open(head_name) as f:
            branch = os.path.basename(f.read().strip())
        remote = repo.config(
            f"branch.{branch}.pushRemote",
            default=repo.config("remote.pushDefault", default=b"origin"),
        ).decode()
        forkpoint = repo.git(
            "merge-base", "--fork-point", "HEAD", f"{remote}/{branch}"
        ).decode()
    else:
        branch = repo.git("symbolic-ref", "--short", "HEAD").decode()
        forkpoint = repo.git("merge-base", branch, "@{upstream}").decode()

    return branch, forkpoint


def main(argv: Optional[List[str]] = None):
    args = parser().parse_args(argv)
    try:
        with Repository() as repo:
            branch, forkpoint = branch_and_forkpoint(repo)
            branch_out_commits_since_forkpoint(repo, branch, forkpoint, args)
    except CalledProcessError as err:
        print(f"subprocess exited with non-zero status: {err.returncode}")
        sys.exit(1)
    except EditorError as err:
        print(f"editor error: {err}")
        sys.exit(1)
    except MergeConflict as err:
        print(f"merge conflict: {err}")
        sys.exit(1)
    except ValueError as err:
        print(f"invalid value: {err}")
        sys.exit(1)


if __name__ == "__main__":
    main()
