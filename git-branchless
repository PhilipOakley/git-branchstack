#!/usr/bin/env python3

import argparse
import os
import re
import sys
from typing import Optional, List, Tuple
from pathlib import Path
from subprocess import CalledProcessError, PIPE, run

from gitrevise.utils import EditorError
from gitrevise.odb import Repository
from gitrevise.merge import rebase, MergeConflict

NAME = "git-branchless"

USAGE = """\
Create some commits with commit messages starting with `[topic] ` where `topic`
is any valid branch name.  Then run `git branchless` to create a branch
for each of those topics among commits in the range `@{upstream}..HEAD`.
Each topic branch is the result of applying the topic's commits on top of
`@{upstream}`.

For example, if you have a history like

    $ git log @{upstream}.. --format=%s
    WIP unfinished commit
    [my-awesome-feature] Some more work on feature
    [some-unrelated-fix] Unrelated fix
    [my-awesome-feature] Initial support for feature

Then this command will create two branches:

    $ git branchless
    Updating refs/heads/my-awesome-feature (ba5e58a => 48a53fec)
    Updating refs/heads/some-unrelated-fix (ba5e58a => e612f26e)

    my-awesome-feature
        9d33b57e Initial support for feature
        48a53fec Some more work on feature

    some-unrelated-fix
        e612f26e Unrelated fix

When you add another commit, or update a previous one, simply re-run `git
branchless` to update the generated topic branches.

Commits whose message does not start with a topic tag are ignored.
Use the special commit message prefix `[]` to reuse the prevous commit's topic.

If there is a merge conflict, you will be prompted to resolve it.  However,
it is usually a good idea to avoid this by using the same topic for dependent
commits.
"""


def branch_out_commits_since_upstream(repo, current_branch, upstream, args) -> None:
    log = []
    patches = (
        repo.git("log", "--reverse", "--oneline", f"{upstream}..HEAD")
        .decode()
        .splitlines()
    )
    current_topic = None
    for line in patches:
        match = re.match(r"^(\S*) \[([^\]]*)\]", line)
        if match is None:
            continue

        commit = match.group(1)
        topic = match.group(2)

        # [] reuses the previous topic
        if topic != "":
            current_topic = topic

        if current_topic:
            log += [(commit, current_topic)]

    topics = sorted(list({l[1] for l in log}))

    assert (
        current_branch not in topics
    ), f"Refusing to overwrite current branch {current_branch}"

    if args.topics:
        if topics:
            print("\n".join(topics))
        sys.exit(0)

    upstream_id = repo.git("rev-parse", upstream).decode()
    for topic in topics:
        head = repo.get_commit(upstream_id)
        new_messages = []
        for commit, t in log:
            if t != topic:
                continue
            patch = repo.get_commit(commit)
            head = rebase(patch, head)
            for prefix in ("[] "), f"[{topic}] ":
                prefix = bytes(prefix, "utf8")
                if head.message.startswith(prefix):
                    head = head.update(message=patch.message[len(prefix) :])
                    break
            new_messages += [head.message]
        if not repo.git("rev-parse", "--revs-only", topic):
            repo.git("branch", topic, upstream)
        topic_ref = repo.get_commit_ref(topic)

        old_commits = (
            repo.git(
                "log", "--reverse", "--oneline", "--format=%H", f"{upstream}..{topic}"
            )
            .decode()
            .splitlines()
        )
        old_messages = [repo.get_commit(commit).message for commit in old_commits]

        if head.tree() == topic_ref.target.tree() and new_messages == old_messages:
            continue

        topic_oid = topic_ref.target.oid
        print(f"Updating {topic_ref.name} ({topic_oid} => {head.oid})")
        topic_ref.update(head, f"{NAME} rewrite")

    for topic in topics:
        print()
        print(topic)
        for line in (
            repo.git("log", "--oneline", f"{upstream}..{topic}").decode().splitlines()
        ):
            print("\t", line)


def parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog=NAME,
        description=USAGE,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    p.add_argument(
        "--topics", "-t", action="store_true", help="print topic branch names and exit",
    )

    return p


def config(repo, key) -> str:
    return repo.git("config", key).decode().strip()


def branch_and_upstream(repo: Repository) -> Tuple[str, str]:
    root = Path(repo.git("rev-parse", "--show-toplevel").decode().strip())
    head_name = root / ".git/rebase-merge/head-name"
    if not os.path.exists(head_name):
        upstream = "@{upstream}"
        branch = repo.git("symbolic-ref", "--short", "HEAD").decode()
        return branch, upstream

    with open(head_name) as f:
        branch = os.path.basename(f.read().strip())
    try:
        remote = config(repo, f"branch.{branch}.remote")
    except:
        remote = "origin"
    upstream = f"{remote}/{branch}"

    return branch, upstream


def main(argv: Optional[List[str]] = None):
    args = parser().parse_args(argv)
    try:
        with Repository() as repo:
            branch, upstream = branch_and_upstream(repo)
            branch_out_commits_since_upstream(repo, branch, upstream, args)
    except CalledProcessError as err:
        print(f"subprocess exited with non-zero status: {err.returncode}")
        sys.exit(1)
    except EditorError as err:
        print(f"editor error: {err}")
        sys.exit(1)
    except MergeConflict as err:
        print(f"merge conflict: {err}")
        sys.exit(1)
    except ValueError as err:
        print(f"invalid value: {err}")
        sys.exit(1)


if __name__ == "__main__":
    main()
